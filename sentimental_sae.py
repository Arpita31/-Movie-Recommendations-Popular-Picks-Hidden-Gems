
# -*- coding: utf-8 -*-
"""Sentimental-SAE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pVOZRKxLQfGiqMRj7O1zFNoGLMD_HIJ5

## Importing Libraries
"""

import numpy as np
import pandas as pd
import torch
import torch.nn as nn
import torch.nn.parallel
import torch.optim as optim
import torch.utils.data
from torch.autograd import Variable
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

"""## Mapping of emotions to likely preferred genres

"""

emotion_genre_mapping = {
    'anger': ['Action', 'Crime', 'Horror', 'Thriller'],
    'fear': ['Horror', 'Mystery', 'Thriller', 'Sci-Fi'],
    'joy': ['Comedy', 'Adventure', 'Animation', 'Musical'],
    'love': ['Romance', 'Drama', 'Comedy'],
    'sadness': ['Drama', 'War', 'Film-Noir'],
    'surprise': ['Fantasy', 'Sci-Fi', 'Adventure', 'Mystery']
}

"""## Importing Datasets"""

# Import data
movies = pd.read_csv('ml-1m/movies.dat', sep='::', header=None, engine='python', encoding='latin-1')
users = pd.read_csv('ml-1m/users.dat', sep='::', header=None, engine='python', encoding='latin-1')
ratings = pd.read_csv('ml-1m/ratings.dat', sep='::', header=None, engine='python', encoding='latin-1')

# Rename columns for clarity
movies.columns = ['MovieID', 'Title', 'Genres']
users.columns = ['UserID', 'Gender', 'Age', 'Occupation', 'Zip-code']
ratings.columns = ['UserID', 'MovieID', 'Rating', 'Timestamp']

# Prepare training and test sets
training_set = pd.read_csv('ml-100k/u1.base', delimiter='\t', names=['UserID', 'MovieID', 'Rating', 'Timestamp'])
training_set = np.array(training_set, dtype='int')
test_set = pd.read_csv('ml-100k/u1.test', delimiter='\t', names=['UserID', 'MovieID', 'Rating', 'Timestamp'])
test_set = np.array(test_set, dtype='int')

"""## Training_set and test_set creation (Users in rows and movies in columns)"""

# Get number of users and movies
nb_users = int(max(max(training_set[:,0]), max(test_set[:,0])))
nb_movies = int(max(max(training_set[:,1]), max(test_set[:,1])))

# Convert data to matrix format (users x movies)
def convert(data):
    new_data = []
    for id_users in range(1, nb_users + 1):
        id_movies = data[:,1][data[:,0] == id_users]
        id_ratings = data[:,2][data[:,0] == id_users]
        ratings = np.zeros(nb_movies)
        ratings[id_movies - 1] = id_ratings
        new_data.append(list(ratings))
    return new_data

training_set = convert(training_set)
test_set = convert(test_set)

# Convert to Torch tensors
training_set = torch.FloatTensor(training_set)
test_set = torch.FloatTensor(test_set)

"""## Emotional Auto Encoder class"""

# Enhanced SAE with emotion embedding
class EmotionalSAE(nn.Module):
    def __init__(self, nb_movies, nb_emotions=6):
        super(EmotionalSAE, self).__init__()
        self.fc1 = nn.Linear(nb_movies, 20)
        self.fc2 = nn.Linear(20, 10)

        # Emotion-specific layer
        self.emotion_embedding = nn.Embedding(nb_emotions, 5)
        self.emotion_fc = nn.Linear(10 + 5, 10)

        self.fc3 = nn.Linear(10, 20)
        self.fc4 = nn.Linear(20, nb_movies)
        self.activation = nn.Sigmoid()

    def forward(self, x, emotion_idx=None):
        x = self.activation(self.fc1(x))
        x = self.activation(self.fc2(x))

        # If emotion is provided, incorporate emotion embedding
        if emotion_idx is not None:
            emotion_embed = self.emotion_embedding(emotion_idx)
            combined = torch.cat((x, emotion_embed), dim=1)
            x = self.activation(self.emotion_fc(combined))

        x = self.activation(self.fc3(x))
        x = self.fc4(x)
        return x

"""## Emotion mapping

"""

# Emotion mapping function
def emotion_to_index(emotion):
    emotions = ['anger', 'fear', 'joy', 'love', 'sadness', 'surprise']
    return emotions.index(emotion.lower())

# Prepare movie genres for similarity comparison
def prepare_genre_data():
    # One-hot encode genres
    genres_list = []
    for genres in movies['Genres']:
        genres_list.append(genres.split('|'))

    # Get unique genres
    all_genres = set()
    for genres in genres_list:
        all_genres.update(genres)
    all_genres = sorted(list(all_genres))

    # Create genre matrix
    genre_matrix = np.zeros((len(movies), len(all_genres)))
    for i, genres in enumerate(genres_list):
        for genre in genres:
            if genre in all_genres:
                genre_matrix[i, all_genres.index(genre)] = 1

    return genre_matrix, all_genres

"""## Training the Auto Encoder model"""

# Initialize model
sae = EmotionalSAE(nb_movies)
criterion = nn.MSELoss()
optimizer = optim.RMSprop(sae.parameters(), lr=0.01, weight_decay=0.5)

# Train the model
nb_epoch = 200
for epoch in range(1, nb_epoch + 1):
    train_loss = 0
    s = 0.
    for id_user in range(nb_users):
        input = Variable(training_set[id_user]).unsqueeze(0)
        target = input.clone()
        if torch.sum(target.data > 0) > 0:
            output = sae(input)
            target.requires_grad = False  # Fixed 'require_grad' to 'requires_grad'
            output[target == 0] = 0
            loss = criterion(output, target)
            mean_corrector = nb_movies/float(torch.sum(target.data > 0) + 1e-10)
            loss.backward()
            train_loss += np.sqrt(loss.data.item() * mean_corrector)  # Fixed loss.data[0] to loss.data.item()
            s += 1.
            optimizer.step()
    print('epoch: '+str(epoch)+' loss: '+str(train_loss/s))

"""## Movie recommendation system"""
# Add this function to incorporate randomness and create two categories of recommendations
def recommend_movies_two_categories(emotion=None, user_id=None, top_n=10, randomness_factor=0.3):
    """
    Recommend movies in two categories:
    1. Popular recommendations
    2. Hidden gems (with added randomness)
    
    Args:
        emotion: Optional emotion to base recommendations on
        user_id: Optional user ID for personalized recommendations
        top_n: Number of movies to recommend in each category
        randomness_factor: Factor to introduce randomness (0.0 to 1.0)
    
    Returns:
        Two lists of movie recommendations: popular and hidden gems
    """
    # Get all ratings data for popularity calculation
    movie_ratings = ratings.groupby('MovieID')['Rating'].agg(['mean', 'count'])
    
    # Define popular movies (high rating, many reviews)
    popular_threshold = 100  # Number of ratings to be considered popular
    popular_movies = movie_ratings[movie_ratings['count'] > popular_threshold]
    popular_movies = popular_movies.sort_values(['mean', 'count'], ascending=False)
    
    # Define potential hidden gems (good rating, fewer reviews)
    min_ratings = 20  # Minimum ratings to be considered (avoid too obscure)
    max_ratings = popular_threshold  # Maximum ratings (not too popular)
    hidden_gems = movie_ratings[(movie_ratings['count'] >= min_ratings) & 
                               (movie_ratings['count'] < max_ratings)]
    hidden_gems = hidden_gems.sort_values('mean', ascending=False)
    
    popular_recommendations = []
    hidden_gem_recommendations = []
    
    # If emotion is provided, filter by preferred genres
    if emotion is not None:
        # Get preferred genres for this emotion
        preferred_genres = emotion_genre_mapping.get(emotion.lower(), [])
        
        # Filter movies by preferred genres
        for category, movie_subset in [("popular", popular_movies), ("hidden", hidden_gems)]:
            recommendations = []
            for movie_id in movie_subset.index.tolist():
                movie_data = movies[movies['MovieID'] == movie_id]
                if len(movie_data) > 0:
                    movie_genres = movie_data.iloc[0]['Genres'].split('|')
                    
                    # Check if movie has any preferred genre
                    if any(genre in preferred_genres for genre in movie_genres):
                        recommendations.append((
                            movie_id,
                            movie_data.iloc[0]['Title'],
                            movie_data.iloc[0]['Genres'],
                            movie_subset.loc[movie_id]['mean'],
                            movie_subset.loc[movie_id]['count']
                        ))
                        
                        # Break when we have enough recommendations
                        if len(recommendations) >= top_n * 2:  # Get more to apply randomness
                            break
            
            # Apply recommendations to appropriate category
            if category == "popular":
                popular_recommendations = recommendations[:top_n]
            else:
                # Apply randomness to hidden gems
                if len(recommendations) > top_n:
                    # Keep some top recommendations
                    top_picks = int(top_n * (1 - randomness_factor))
                    random_picks = top_n - top_picks
                    
                    # Get top picks
                    top_hidden_gems = recommendations[:top_picks]
                    
                    # Get random picks from the rest
                    remaining = recommendations[top_picks:len(recommendations)]
                    np.random.shuffle(remaining)
                    random_hidden_gems = remaining[:random_picks]
                    
                    hidden_gem_recommendations = top_hidden_gems + random_hidden_gems
                else:
                    hidden_gem_recommendations = recommendations[:top_n]
    else:
        # No emotion provided, just use general popularity
        popular_recommendations = [(
            movie_id,
            movies[movies['MovieID'] == movie_id].iloc[0]['Title'],
            movies[movies['MovieID'] == movie_id].iloc[0]['Genres'],
            popular_movies.loc[movie_id]['mean'],
            popular_movies.loc[movie_id]['count']
        ) for movie_id in popular_movies.index.tolist()[:top_n]]
        
        # Apply randomness to hidden gems
        top_hidden = int(top_n * (1 - randomness_factor))
        random_hidden = top_n - top_hidden
        
        # Get top hidden gems
        top_hidden_gems = [(
            movie_id,
            movies[movies['MovieID'] == movie_id].iloc[0]['Title'],
            movies[movies['MovieID'] == movie_id].iloc[0]['Genres'],
            hidden_gems.loc[movie_id]['mean'],
            hidden_gems.loc[movie_id]['count']
        ) for movie_id in hidden_gems.index.tolist()[:top_hidden]]
        
        # Get random picks from remaining hidden gems
        remaining_indices = hidden_gems.index.tolist()[top_hidden:min(len(hidden_gems), top_hidden + top_n * 2)]
        np.random.shuffle(remaining_indices)
        random_hidden_gems = [(
            movie_id,
            movies[movies['MovieID'] == movie_id].iloc[0]['Title'],
            movies[movies['MovieID'] == movie_id].iloc[0]['Genres'],
            hidden_gems.loc[movie_id]['mean'],
            hidden_gems.loc[movie_id]['count']
        ) for movie_id in remaining_indices[:random_hidden]]
        
        hidden_gem_recommendations = top_hidden_gems + random_hidden_gems
    
    # Sort both lists by rating
    popular_recommendations.sort(key=lambda x: (x[3], x[4]), reverse=True)
    hidden_gem_recommendations.sort(key=lambda x: x[3], reverse=True)
    
    return popular_recommendations, hidden_gem_recommendations


# Example usage
def get_recommendations_for_emotion(emotion, user_id=None):
    print(f"Recommended movies for emotion: {emotion}")
    recommendations = recommend_movies_two_categories(emotion, user_id)

    for i, (movie_id, title, genres) in enumerate(recommendations):
        print(f"{i+1}. {title} - {genres}")
